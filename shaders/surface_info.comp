#version 430 core

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

uniform vec3 queryPosition;
uniform float planetRadius;
uniform float heightScale;
uniform float seaLevel;
uniform mat3 worldToPlanet;
uniform float minAltitudeOffset;
uniform sampler3D terrainNoise;
uniform float terrainNoiseSize;

layout(std430, binding = 0) buffer SurfaceInfo {
    vec4 data0; // xyz = surface normal, w = surface radius
    vec4 data1; // x = altitude, y = terrain height, z = clamped surface radius, w = unused
};

float noise(vec3 p) {
    vec3 cell = floor(p);
    vec3 f = fract(p);
    vec3 wrappedCell = mod(cell, terrainNoiseSize);
    vec3 coord = (wrappedCell + f) / terrainNoiseSize;
    return texture(terrainNoise, coord).r;
}

float fbm(vec3 p) {
    float v = 0.0;
    float a = 0.5;
    for (int i = 0; i < 5; i++) {
        v += a * noise(p);
        p *= 2.0;
        a *= 0.5;
    }
    return v;
}

float terrainHeight(vec3 p) {
    vec3 scaledP = p / planetRadius;

    float warpFreq = 1.15;
    float warpAmp = 0.06;

    vec3 warp = vec3(
        fbm(scaledP * warpFreq + vec3(11.7)),
        fbm(scaledP * warpFreq + vec3(3.9, 17.2, 5.1)),
        fbm(scaledP * warpFreq - vec3(7.5))
    );

    vec3 warpedP = scaledP * 8.0 + (warp - 0.5) * 2.0 * warpAmp;

    float base = fbm(warpedP);
    float detail = fbm(warpedP * 2.5) * 0.35;

    float normalized = base * 0.62 + detail * 0.38;
    return (normalized - 0.42) * heightScale;
}

void main() {
    vec3 planetPos = worldToPlanet * queryPosition;
    float heightValue = terrainHeight(planetPos);
    float surfaceRadius = planetRadius + heightValue;
    float clampedSurfaceRadius = surfaceRadius + max(minAltitudeOffset, 0.0);

    float dist = length(queryPosition);
    float altitude = dist - surfaceRadius;
    vec3 surfaceNormal = dist > 0.0 ? queryPosition / dist : vec3(0.0, 1.0, 0.0);

    data0 = vec4(surfaceNormal, surfaceRadius);
    data1 = vec4(altitude, heightValue, clampedSurfaceRadius, 0.0);
}
