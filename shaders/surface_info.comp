#version 430 core

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

uniform vec3 queryPosition;
uniform float planetRadius;
uniform float heightScale;
uniform float seaLevel;
uniform mat3 worldToPlanet;
uniform float minAltitudeOffset;

layout(std430, binding = 0) buffer SurfaceInfo {
    vec4 data0; // xyz = surface normal, w = surface radius
    vec4 data1; // x = altitude, y = terrain height, z = clamped surface radius, w = unused
};

vec3 hash3(vec3 p) {
    p = vec3(
        dot(p, vec3(127.1, 311.7, 74.7)),
        dot(p, vec3(269.5, 183.3, 246.1)),
        dot(p, vec3(113.5, 271.9, 124.6))
    );
    return fract(sin(p) * 43758.5453);
}

float gradientNoise(vec3 p) {
    vec3 i = floor(p);
    vec3 f = fract(p);
    vec3 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);

    vec3 g000 = hash3(i + vec3(0.0, 0.0, 0.0)) * 2.0 - 1.0;
    vec3 g001 = hash3(i + vec3(0.0, 0.0, 1.0)) * 2.0 - 1.0;
    vec3 g010 = hash3(i + vec3(0.0, 1.0, 0.0)) * 2.0 - 1.0;
    vec3 g011 = hash3(i + vec3(0.0, 1.0, 1.0)) * 2.0 - 1.0;
    vec3 g100 = hash3(i + vec3(1.0, 0.0, 0.0)) * 2.0 - 1.0;
    vec3 g101 = hash3(i + vec3(1.0, 0.0, 1.0)) * 2.0 - 1.0;
    vec3 g110 = hash3(i + vec3(1.0, 1.0, 0.0)) * 2.0 - 1.0;
    vec3 g111 = hash3(i + vec3(1.0, 1.0, 1.0)) * 2.0 - 1.0;

    float n000 = dot(g000, f - vec3(0.0, 0.0, 0.0));
    float n001 = dot(g001, f - vec3(0.0, 0.0, 1.0));
    float n010 = dot(g010, f - vec3(0.0, 1.0, 0.0));
    float n011 = dot(g011, f - vec3(0.0, 1.0, 1.0));
    float n100 = dot(g100, f - vec3(1.0, 0.0, 0.0));
    float n101 = dot(g101, f - vec3(1.0, 0.0, 1.0));
    float n110 = dot(g110, f - vec3(1.0, 1.0, 0.0));
    float n111 = dot(g111, f - vec3(1.0, 1.0, 1.0));

    float nx00 = mix(n000, n100, u.x);
    float nx10 = mix(n010, n110, u.x);
    float nx01 = mix(n001, n101, u.x);
    float nx11 = mix(n011, n111, u.x);

    float nxy0 = mix(nx00, nx10, u.y);
    float nxy1 = mix(nx01, nx11, u.y);

    return mix(nxy0, nxy1, u.z) * 0.7071;
}

float fbm(vec3 p) {
    float v = 0.0;
    float a = 0.55;
    float f = 1.0;
    for (int i = 0; i < 6; i++) {
        v += a * gradientNoise(p * f);
        f *= 2.0;
        a *= 0.5;
    }
    return v;
}

float ridgedFbm(vec3 p) {
    float v = 0.0;
    float a = 0.8;
    float f = 0.75;
    for (int i = 0; i < 4; i++) {
        float n = 1.0 - abs(gradientNoise(p * f));
        v += n * n * a;
        f *= 2.0;
        a *= 0.55;
    }
    return clamp(v, 0.0, 1.2);
}

float terrainHeight(vec3 p) {
    vec3 scaledP = p / planetRadius;

    float warpFreq = 0.95;
    float warpAmp = 0.1;

    vec3 warp = vec3(
        fbm(scaledP * warpFreq + vec3(11.7)),
        fbm(scaledP * warpFreq + vec3(3.9, 17.2, 5.1)),
        fbm(scaledP * warpFreq - vec3(7.5))
    );

    vec3 macroWarp = (warp - 0.5) * 2.0 * warpAmp;
    vec3 continentP = scaledP * 0.5 + macroWarp * 0.45;
    vec3 warpedP = scaledP * 6.2 + macroWarp;

    float continents = ridgedFbm(continentP);
    continents = pow(continents, 1.35);

    float mid = fbm(warpedP * 1.8);
    float detail = fbm(warpedP * 3.5) * 0.28;

    float normalized = continents * 0.62 + mid * 0.28 + detail * 0.1;
    return (normalized - 0.55) * heightScale;
}

void main() {
    vec3 planetPos = worldToPlanet * queryPosition;
    float heightValue = terrainHeight(planetPos);
    float surfaceRadius = planetRadius + heightValue;
    float clampedSurfaceRadius = surfaceRadius + max(minAltitudeOffset, 0.0);

    float dist = length(queryPosition);
    float altitude = dist - surfaceRadius;
    vec3 surfaceNormal = dist > 0.0 ? queryPosition / dist : vec3(0.0, 1.0, 0.0);

    data0 = vec4(surfaceNormal, surfaceRadius);
    data1 = vec4(altitude, heightValue, clampedSurfaceRadius, 0.0);
}
