#version 430 core

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

uniform vec3 queryPosition;
uniform float planetRadius;
uniform float heightScale;
uniform float seaLevel;
uniform mat3 worldToPlanet;
uniform float minAltitudeOffset;
uniform sampler3D terrainNoise;
uniform float terrainNoiseSize;

layout(std430, binding = 0) buffer SurfaceInfo {
    vec4 data0; // xyz = surface normal, w = surface radius
    vec4 data1; // x = altitude, y = terrain height, z = clamped surface radius, w = unused
};

float noise(vec3 p) {
    // Use normalized coordinates that cover the full seamless noise volume
    // instead of sampling a tiny texel neighborhood near the origin.
    vec3 coord = fract(p * 0.5 + 0.5);
    return texture(terrainNoise, coord).r;
}

float fbm(vec3 p) {
    float v = 0.0;
    float a = 0.5;
    for (int i = 0; i < 5; i++) {
        v += a * noise(p);
        p *= 2.0;
        a *= 0.5;
    }
    return v;
}

float terrainHeight(vec3 p) {
    vec3 scaledP = p / planetRadius;

    vec3 warp = vec3(
        fbm(scaledP * 0.85 + vec3(4.3, 2.1, -6.7)),
        fbm(scaledP * 0.85 + vec3(-7.1, 5.4, 1.3)),
        fbm(scaledP * 0.85 + vec3(3.2, -4.8, 7.9))
    );

    vec3 warpedP = scaledP * 1.65 + (warp - 0.5) * 0.55;

    float continental = fbm(warpedP * 0.75);
    continental = smoothstep(0.25, 0.68, continental);

    float shelf = fbm(warpedP * 1.35);
    float landMask = clamp(continental * 0.75 + shelf * 0.35, 0.0, 1.0);

    float plains = fbm(warpedP * 2.4) * 0.35;

    float ridged = 1.0 - abs(fbm(warpedP * 3.4) * 2.0 - 1.0);
    float mountains = pow(ridged, 3.0) * smoothstep(0.58, 0.9, landMask);

    float deepSea = (1.0 - landMask) * 0.38;

    float height = landMask * 0.55 + plains * 0.28 + mountains * 0.42 - deepSea - 0.28;

    return height * heightScale;
}

void main() {
    vec3 planetPos = worldToPlanet * queryPosition;
    float heightValue = terrainHeight(planetPos);
    float surfaceRadius = planetRadius + heightValue;
    float clampedSurfaceRadius = surfaceRadius + max(minAltitudeOffset, 0.0);

    float dist = length(queryPosition);
    float altitude = dist - surfaceRadius;
    vec3 surfaceNormal = dist > 0.0 ? queryPosition / dist : vec3(0.0, 1.0, 0.0);

    data0 = vec4(surfaceNormal, surfaceRadius);
    data1 = vec4(altitude, heightValue, clampedSurfaceRadius, 0.0);
}
